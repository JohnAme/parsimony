\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}
\usepackage{setspace}
\usepackage{courier}
\usepackage[toc, page]{appendix}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{adjustbox}
\usepackage{amssymb}
\usepackage{underscore}
\usepackage{textcomp}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{csquotes}

\newtheorem{statement}{Statement}

\newcommand{\statenumstate}{7,910-state }
\newcommand{\statenum}{7,910 }
\newcommand{\statenumcomma}{7,910, }
\newcommand{\bbstatenum}{$BB($7,910) }
\newcommand{\bbstatenumcomma}{$BB($7,910), }
\newcommand{\bbstatenumperiod}{$BB($7,910). }
\newcommand{\bbbitsperiod}{157,819.}

\newcommand{\zhaltstate}{\texttt{7862}}
\newcommand{\ghaltstate}{\texttt{5135}}
\newcommand{\rhaltstate}{\texttt{5137}}

\newcommand{\gbstatenum}{4,888 }
\newcommand{\gbstatenumstate}{4,888-state }
\newcommand{\bbgbstatenum}{$BB($4,888) }

\newcommand{\rmstatenum}{5,372 }
\newcommand{\rmstatenumstate}{5,372-state }
\newcommand{\bbrmstatenum}{$BB($5,372) }

\newenvironment{nscenter}
 {\parskip=0pt\par\nopagebreak\centering}
 {\par\noindent\ignorespacesafterend}

\setcounter{secnumdepth}{4}

\begin{document}

\title{A Relatively Small Turing Machine Whose Behavior Is Independent of Set Theory}
\author{
    Adam Yedidia\\
    \small\texttt{MIT}\\
    \small\texttt{adamy@mit.edu}
    \and
    Scott Aaronson\\
    \small\texttt{MIT}\\
    \small\texttt{aaronson@csail.mit.edu}
}
\maketitle

\begin{abstract}

Since the definition of the Busy Beaver function by Rad\'{o} in 1962, an interesting open question has been the smallest value of $n$ for which $BB(n)$ is independent of ZFC set theory. \ Is this $n$ approximately $10$, or closer to 1,000,000, or is it even larger? \ In this paper, we show that it is at most \statenum by presenting an explicit description of a \statenumstate Turing machine $Z$ with 1 tape and a 2-symbol alphabet that cannot be proved to run forever in ZFC (even though it presumably does), assuming ZFC is consistent. \ The machine is based on work of Harvey Friedman on independent statements involving order-invariant graphs. \ In doing so, we give the first known upper bound on the highest provable Busy Beaver number in ZFC. \ To create $Z$, we develop and use a higher-level language, Laconic, which is much more convenient than direct state manipulation. \ We also use Laconic to design two Turing machines, $G$ and $R$, that halt if and only if there are counterexamples to Goldbach's Conjecture and the Riemann Hypothesis, respectively.

\end{abstract}

\section{Introduction}

%\subsection{Contributions}

%This paper is devoted to demonstrating the extreme difficulty of finding the values of the Busy Beaver function beyond a certain point. We cannot ever prove an upper bound on $BB(x)$ for any $x \ge \gbstatenum$ or $x \ge \rmstatenum$ without simultaneously providing a proof (or disproof) of the Goldbach or Riemann hypotheses, respectively. And we cannot ever prove an upper bound on $BB(x)$ for any $x \ge \statenum$ without assuming axioms more powerful than those of Zermelo-Fraenkel Set Theory with the Axiom of Choice (a.k.a. ZFC), assuming ZFC is consistent.\footnotemark
%\footnotetext{While we will talk about ZFC throughout this paper, rather than simple Zermelo-Fraenkel set theory, this is simply convention brought about by the fact that ZFC is a more powerful and more commonly-used set of axioms. In fact, for the purposes of this paper, the Axiom of Choice is irrelevant: the consistency of ZFC is equivalent to the consistency of simple ZF set theory,~\cite{godelcohen} and ZFC and ZF prove exactly the same arithmetical statements (which include, among other things, Turing machine execution histories).~\cite{schoenfield}}

%We demonstrate these results by presenting explicit descriptions of Turing machines, $G$, $R$, and $Z$ whose \emph{behavior} (whether or not they halt) implies the truth or falsehood of the Goldbach and Riemann hypotheses and the consistency of ZFC, respectively. If one knew a proof that $\bbstatenum < u_G$ for some $u_G$, one could find out if $G$ halts or loops by running $G$ for $u_G$ steps and seeing if it had halted by then; if it had not, we would be certain that $G$ will never halt. Thus, an execution history of $G$ for $u_G$ steps would constitute a proof of the truth or falsehood of Goldbach's conjecture. The same logic holds for $R$, \bbrmstatenum, and the Riemann hypothesis.

%Likewise, if one knew a proof that \bbstatenum$ \le u_Z$, one could find out if $Z$ halts or loops by running $Z$ for $u_Z$ steps $Z$ for $u_Z$ steps and seeing if it had halted by then; if it had not, we would be certain that $Z$ will never halt. Thus, an execution history of $Z$ for $u_Z$ steps would constitute a proof in ZFC (since ZFC can encode arithmetic, and therefore Turing machine execution histories) of the consistency or inconsistency of ZFC. By G\"{o}del's second incompleteness theorem, such a proof cannot exist if ZFC is consistent. Thus, no proof in ZFC exists of an upper bound on the value of \bbstatenum, assuming ZFC is consistent.

\subsection{Background and Motivation \label{sec:background}}

\emph{Zermelo-Fraenkel set theory with the axiom of choice}, more commonly known as ZFC, is an axiomatic system invented in the twentieth century which has since been used as the foundation of most of modern mathematics. \ It encodes arithmetic by describing natural numbers as increasing sets of sets.

Like any axiomatic system capable of encoding arithmetic, ZFC is constrained by G\"{o}del's two incompleteness theorems. \ The first incompleteness theorem states that if ZFC is \emph{consistent} (it never proves both a statement and its opposite), then ZFC cannot also be \emph{complete} (able to prove every true statement). \ The second incompleteness theorem states that if ZFC is consistent, then ZFC cannot prove its own consistency. \ Because we have built modern mathematics on top of ZFC, we can reasonably be said to have assumed ZFC's consistency. \ This means that we must also believe that ZFC cannot prove its own consistency. \ This fact carries with it certain surprising conclusions.

In particular, consider a Turing machine $Z$ that enumerates, one after the other, each of the provable statements in ZFC. \ To describe how such a machine might be constructed, $Z$ could iterate over the axioms and inference rules of ZFC, applying each in every possible way to each conclusion or pair of conclusions that had been reached so far. \ We might ask $Z$ to halt if it ever reaches a contradiction; in other words, $Z$ will halt if and only if it finds a proof of $0 = 1$. \ Because this machine will enumerate \emph{every} provable statement in ZFC, it will run forever if and only if ZFC is consistent.

It follows that $Z$ is a Turing machine for which the question of its behavior (whether or not it halts when run indefinitely) is equivalent to the consistency of ZFC.\footnote{While we will talk about ZFC throughout this paper, rather than simple ZF set theory, this is simply a convention. \ For our purposes, the Axiom of Choice is irrelevant: the consistency of ZFC is equivalent to the consistency of simple ZF set theory,~\cite{godelcohen} and ZFC and ZF prove exactly the same arithmetical statements (which include, among other things, statements about whether Turing machines halt).~\cite{schoenfield}} \ Therefore, just as ZFC cannot prove its own consistency (assuming ZFC is consistent), ZFC also cannot prove that $Z$ will run forever. In other words, the statement, ``$Z$ will run forever'' is \emph{independent of} ZFC.

This is interesting because, while the undecidability of the halting problem tells us that there cannot exist an algorithmic method for determining whether an \emph{arbitrary} Turing machine loops or halts, $Z$ is an example of a \emph{specific} Turing machine whose behavior cannot be proven one way or the other using the foundation of modern mathematics. \ Mathematicians and computer scientists think of themselves as being able to determine how a given algorithm will behave if given enough time to stare at it; despite this intuition, $Z$ is a machine whose behavior we can never prove without assuming axioms more powerful than those generally assumed in modern mathematics.

\subsection{Turing Machines \label{sec:tm}}

There are many slightly different definitions of Turing machines. \ For example, some definitions allow the machine to have multiple tapes; others only allow it to have one; some allow an arbitrarily large alphabet, while others allow only two symbols, and so on. \ In most research regarding Turing machines, mathematicians don't concern themselves with which of these models to use, because any one can simulate the others (usually efficiently). \ However, because this work is concerned with upper-bounding the exact number of states required to perform certain tasks, it's important to define the model precisely. \ The model we choose here is traditional for the Busy Beaver function.

Formally, a $k$-state Turing machine is a 7-tuple $M = (Q, \Gamma, a, \Sigma, \delta, q_0, F)$, where: \\ \\
$Q$ is the set of $k$ \emph{states} $\{q_0, q_1, \dots, q_{k-2}, q_{k-1}\}$ \\
$\Gamma = \{a, b\}$ is the set of \emph{tape alphabet symbols} \\
\texttt{a} is the \emph{blank symbol} \\
$\Sigma = \empty$ is the set of \emph{input symbols} \\
$\delta = Q \times \Gamma \rightarrow (Q \cup F) \times \Gamma \times \{L, R\}$ is the \emph{transition function} \\
$q_0$ is the \emph{start state} \\
$F = \{\textrm{HALT}, \textrm{ERROR}\}$ is the set of \emph{halting states}. \\

A Turing machine's \emph{states} make up the Turing machine's easily-accessible, finite memory. \ The Turing machine's state is initialized to $q_0$.

The \emph{tape alphabet symbols} correspond to the symbols that can be written on the Turing machine's infinite tape.

In this work, all Turing machines are run on the all-\texttt{a} input.

The \emph{transition function} encodes the Turing machine's behavior. \ It takes two inputs: the current state of the Turing machine (an element of $Q \cup F$) and the symbol read off the tape (an element of $\Gamma$). \ It outputs three instructions: what state to enter (an element of $Q \cup F$), what symbol to write onto the tape (an element of $\Gamma$) and what direction to move the head in (an element of $\{L, R\}$). \ A transition function specifies the entire behavior of the Turing machine in all cases.

The \emph{start state} is the state that the Turing machine is in at initialization.

A \emph{halting transition} is a transition to a halting state, which causes the Turing machine to halt. \ While having three possible halting transitions is not necessary for our purposes, being able to differentiate between different types of halting (HALT and ERROR) is useful for testing.

\subsection{The Busy Beaver Function}

Consider the set of all Turing machines with $k$ states, for some positive integer $k$. \ We call a Turing machine $B$ a $k$\emph{-state Busy Beaver} if when run on the empty tape as input, $B$ halts, and also runs for at least as many steps before halting as all other halting $k$-state Turing machines.~\cite{busybeaver}

In other words, a Busy Beaver is a Turing machine that runs for at least as long as all other halting Turing machines with the same number of states. \ Another common definition for a Busy Beaver is a Turing machine that writes as many 1's on the tape as possible; because the number of 1's written is a somewhat arbitrary measure, it is not used in this work.

The \emph{Busy Beaver function}, written $BB(k)$, equals the number of steps it takes for a $k$-state Busy Beaver to halt. \ The Busy Beaver function has many striking properties. \ To begin with, it is not \emph{computable}; in other words, there does not exist an algorithm that takes $k$ as input and returns $BB(k)$, for arbitrary values of $k$. \ This follows directly from the undecidability of the halting problem. \ Suppose an algorithm existed to compute the Busy Beaver function; then given a $k$-state Turing machine $M$ as input, we could compute $BB(k)$ and run $M$ for $BB(k)$ steps. \ If, after $BB(k)$ steps, $M$ had not yet halted, we could safely conclude that $M$ would never halt. \ Thus, we could solve the halting problem, which we know is impossible.

By the same argument, $BB(k)$ must grow faster than any computable function. \ (To check this, assume that some computable function $f(k)$ grows faster than $BB(k)$, and substitute $f(k)$ for $BB(k)$ in the rest of the proof.) \ In particular, the Busy Beaver grows even faster than (for instance) the Ackermann function, a well-known fast-growing function.

Because finding the value of $BB(k)$ for a given $k$ requires so much work (one must fully explore the behavior of all $k$-state Turing machines), few explicit values of the Busy Beaver function are known. \ The known values are~\cite{bbfour,bbsmall}:

$$BB(1) = 1$$
$$BB(2) = 6$$
$$BB(3) = 21$$
$$BB(4) = 107$$

For $BB(5)$, $BB(6)$, and $BB(7)$ only lower bounds are known~\cite{bbvalues,bigbbvalues}:

$$BB(5) \ge \textrm{47,176,870}$$
$$BB(6) > 7.4 \times 10^{\textrm{36,534}}$$
$$BB(7) > 10^{10^{10^{10^{10^7}}}}$$

Additionally, $BB(22)$ is known to be larger than Graham's Number (a famous huge number from Ramsey theory, obtained by iterating the Ackermann function 64 times)~\cite{grahamsnumber}. \ Researchers have worked on pinning down the value of $BB(5)$ exactly, and some consider it to be possibly within reach.

Another way to discuss the Busy Beaver sequence is to say that modern mathematics has established a \emph{lower bound} of $4$ on the highest provable Busy Beaver value. \ In this paper, we prove the first known \emph{upper bound} on the highest provable Busy Beaver value in ZFC; that is, we give a value of $k$, namely \statenumcomma such that the value of $BB(k)$ cannot be proven in ZFC.

Intuitively, one might expect that while no algorithm may exist to compute $BB(k)$ for \emph{all} values of $k$, we could find the value of $BB(k)$ for any \emph{specific} $k$ using a procedure similar to the one we used to find the value of $BB(k)$ for $k \le 4$. \ The reason this is not so is closely tied to the existence of a machine like the G\"{o}delian machine $Z$, as described in Section~\ref{sec:background}. \ Suppose that $Z$ has $k$ states. Because $Z$'s behavior (whether it halts or loops) cannot be proven in ZFC, it follows that the value of $BB(k)$ also can't be proven in ZFC; if it could, then a proof would exist of $Z$'s behavior in ZFC. \ Such a proof would consist of a \emph{computation history} for $Z$, which is an explicit step-by-step description of $Z$'s behavior for a certain number of steps. \ If $Z$ halts, then a computation history leading up to $Z$'s halting would be the entire proof; if $Z$ loops, then a computation history that takes $BB(k)$ steps, combined with a proof of the value of $BB(k)$, would constitute a proof that $Z$ will run forever.

In this paper we construct a machine like $Z$, for which a proof that $Z$ runs forever would imply that ZFC was consistent. \ In doing so, we give an explicit upper bound on the highest Busy Beaver value provable in ZFC assuming the consistency of a slightly stronger set theory. \ Our machine, which we shall refer to as $Z$ hereafter, contains \statenum states. \ Therefore, we will never be able to prove the value of \bbstatenum without assuming more powerful axioms than those of ZFC. \ This upper bound is presumably very far from tight, but it is a first step.

Even to achieve a state count of \statenumcomma we will need three nontrivial ideas: Harvey Friedman's order-theoretic statements, \emph{on-tape processing}, and \emph{introspective encoding}. \ Without all three ideas, we found that the state count would be in the tens of thousands, hundreds of thousands, or even millions. \ We briefly introduce these ideas in the following subsection, and explore them in much greater detail in Section \ref{sec:compandproc}. \ The implementation of these ideas constitutes this paper's main technical contribution.

\subsection{Parsimony}

In most algorithmic study, efficiency is the primary concern. \ In designing $Z$, however, parsimony is the only thing that matters. \ One historical analogue is the practice of ``code-golfing'': a recreational pursuit adopted by some programmers in which the goal is to produce a piece of code in a given programming language, using as few characters as possible. \ Many examples of code-golfing can be found at~\cite{codegolf}. \ The goal of designing a Turing machine with as few states as possible to accomplish a certain task, without concern for the machine's efficiency or space usage, can be thought of as code-golfing with a particularly low-level programming language.

Part of the charm of Turing machines is that they give us a ``standard reference point'' for measuring complexity, unencumbered by the details of more sophisticated programming languages. \ Also, with Turing machines, there can be no suspicion that we engineered a programming formalism just for the purpose of code-golfing, or for making the concepts we want artificially simple to describe. \ This is why we prefer Turing machines as a tool for measuring complexity; not because they are particularly special, but simply because they are so primitive that their specifics will interfere minimally with what we mean by an algorithm being ``complicated.''

In this paper, we use three ideas for generating parsimonious Turing machines: Harvey Friedman's mathematical statements, \emph{on-tape processing}, and \emph{introspective} Turing machines. \ The last of these ideas was proposed, under a different name and with some variations, by Ben-Amram and Petersen in 2002 \cite{benamram}. \ These three ideas are explained in more detail in Subsections~\ref{sec:friedmanstate},~\ref{sec:ontape}, and~\ref{sec:introspect}, respectively, but we summarize them very briefly here.

The first idea is simply to use the research done by Friedman into finding simple-to-express statements that are equivalent to the consistency of various axiomatic systems. \ In particular, we use a statement discovered by Friedman to be equivalent to the consistency of a set theory stronger than ZFC (and whose consistency, therefore, would imply the consistency of ZFC).\footnote{Admittedly, it's not obvious that using Friedman's current statements \emph{does} decrease the state count of the Turing machines. \ It's possible that one could do as well or better by directly searching for contradictions in ZFC, and indeed, recent unpublished work by Stefan O'Rear has given some evidence for that~\cite{comments}. \ On the other hand, Friedman's statements can be translated into code without using the apparatus of first-order logic, which arguably gives us a conceptual simplification. \ In addition, statements like Friedman's seem like the most plausible path forward for \emph{further} reductions in the state count, beyond whatever lower limit one hits when one needs to encode the ZFC axioms explicitly.}~\cite{friedman}

The second idea, on-tape processing, is a way to encode high-level commands into a Turing machine parsimoniously. \ Instead of converting commands to groups of states directly, which incurs a multiplicative overhead based on how large these groups need to be, on-tape processing begins by writing the commands onto the tape, using as efficient an encoding as possible. \ Then, once the commands are on the tape, the commands are processed by a single group of states that understands how to interpret them.

The third idea, introspective Turing machines, is a way to write long strings onto the tape using as few states as possible. \ The idea is to encode information one of each state's transitions, instead of encoding information in each state's write field. \ This is advantageous because there are many choices for which state to point a transition to, but only two choices for which bit to write. \ Therefore, more information can be encoded in each state using this method.

\subsection{Implementation Overview}

To generate descriptions of Turing machines with nice mathematical properties entirely by hand is a daunting task. \ Rather than approach the problem directly, we created tools for generating parsimonious Turing machines while presenting an interface that is comfortably familiar to most programmers (and to us!).

We created two tools. At the top level is the Laconic programming language, whose syntax and capabilities are similar to those of most programming languages, such as Java or Python. \ Beneath it we created a lower-level language called Turing Machine Descriptor (TMD). \ TMD is quite unlike most programming languages, and is better thought of as a convenient way to describe a multi-tape, 3-symbol Turing machine plus a function stack. \ The style of multi-tape Turing machine used in TMD is the commonly used ``one-tape-at-a-time'' abstraction: only one tape at a time can be interacted with, for reading, writing, and moving the head. Laconic compiles down to a TMD program, and TMD compiles down to a description of a single-tape, 2-symbol Turing machine. \ This process is illustrated in Figure~\ref{fig:compilation}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.42]{figs/compilation.png}
\caption{A visual overview of the compilation process. \label{fig:compilation}}
\end{center}
\end{figure}

We recommend that programmers hoping to use our tools to generate their own encodings of mathematical statements or algorithms as Turing machines use Laconic. \ Laconic's interface is perfect for somebody hoping to write in a ``traditional'' language. \ On the other hand, if the programmer wishes to improve upon Laconic's compilation process, writing code directly in TMD is likely to be the better option.

\section{Related Work}

Gregory Chaitin raised the problem of proving a version of our result in his book \emph{The Limits of Mathematics}.~\cite{chaitin} \ He wrote:

\begin{displayquote}
\noindent I would like to have somebody program out Zermelo-Fraenkel set theory in my version of LISP, which is pretty close to normal LISP as far as this task is concerned, just to see how many bits of complexity mathematicians normally assume \dots If you programmed ZF, you'd get a really sharp incompleteness result. \ It wouldn't say that you can get at most $H(ZF) + 15328$ bits of [Chaitin's halting probability] $\Omega$, it would say, perhaps, at most 96000 bits! \ We'd have a much more definite incompleteness theorem.
\end{displayquote}

We did not program ZF set theory in LISP, but we programmed it in an even simpler language---thereby answering Chaitin's call for an explicit number of bits to attach to the complexity of ZF set theory. (As many as required to fully describe our Turing machine---or more precisely, \bbbitsperiod)

This paper is not the first to attempt to quantify the complexity of arithmetical statements. \ Calude and Calude~\cite{calude} define a register machine of their own design, and provide quantifications of the complexity of Legendre's Conjecture, Fermat's Last Theorem, Goldbach's Conjecture, Dyson's Conjecture, the Riemann Hypothesis, and the Four Color Theorem.\footnote{Because Fermat's Last Theorem and the Four Color Theorem have been proved, their ``complexity'' is now known to be $1$---the minimum number of states in a Turing machine that runs forever.}
In addition, Koza~\cite{koza} and Pargellis~\cite{pargellis} each invent instruction sets that are particularly well-suited to representing self-reproducing programs simply, and show that starting from a ``primordial soup'' of such instructions distributed about a large memory, along with an increasing number of program threads, a rich ecosystem of increasingly efficient self-reproducing programs start to dominate the ``landscape.''

This paper differs from the previous work in two ways: firstly, it's the first to give explicit, relatively small machines whose behavior is provably independent of the standard axioms of modern mathematics. \ Secondly, to our knowledge, this paper is the first concrete study of parsimony to use Turing machines themselves as the model of computation---rather than (for example) a new programming language proposed by the authors, or a complex on-tape description of Turing machines! \ We consider it important to use the weakest and most common model of computation for complexity comparisons across different mathematical statements. \ This is because the more powerful and complex the model of computation used, the more of the complexity of the algorithm can be ``shunted'' onto the model of computation, and the greater the potential distortion created by the choice of model. \ As a reductio ad absurdum, we could imagine a programming language that included ``test the Riemann Hypothesis'' and ``test the consistency of ZFC'' as primitive operations. \ By using the ``weakest'' model of computation that's commonly known, we hope to avoid this pitfall and make it easier to interpret our results in a model-independent way.

Also related to the work of this paper is the famous search for the smallest universal Turing machine, which has a relatively long history. \ A survey is available at~\cite{universalsurvey}. \ Here a \emph{universal Turing machine} is a Turing machine that can simulate any other Turing machine, when a description of the latter is provided on its input tape. \ The smallest-known universal Turing machine has only $2$ states and a $3$-symbol alphabet. \ It was found and conjectured to be universal by Stephen Wolfram~\cite{newscience} and then proved to be universal by Alex Smith~\cite{universal} in 2007. \ The search for the smallest universal Turing machine is closely related to the smallest Turing machine that is independent of ZFC, in that both constitute a search for simplicity according to some rigorous metric. \ From the perspective of this paper, however, the problem is that the known small universal Turing machines achieve their small size only at the cost of an extremely complicated description format for the input machine. \ I.e., most of the complexity gets ``shunted'' from the Turing machine itself to the input encoding format. \ By contrast, with small Turing machines to test $Con(ZFC)$, the Riemann Hypothesis, Goldbach's Conjecture, etc., and which run on an initially blank tape, there's no analogous trick for hiding the statement's complexity.

Finally, let us mention that, after we circulated a preprint of this
work, Stefan O'Rear~\cite{stefan} created a
different 1919-state Turing machine whose behavior is equivalent to
the consistency of ZFC.  O'Rear was directly inspired to do this by
our result; his result, however, is stronger than ours in two ways.
First, his machine is substantially smaller than ours, yielding a
tighter upper bound on the lowest Busy Beaver number whose value is
independent of ZFC. Second, the non-halting of his machine is directly
equivalent to Con(ZFC), whereas proving the non-halting of our machine
seems to require assuming the consistency of a stronger system than
ZFC (known as ``stationary Ramsey property'').

In order to create his machine, O'Rear adapted our Laconic language,
creating a slightly different language which he called Not Quite
Laconic (NQL).  O'Rear then wrote a short NQL program that directly
iterates through all theorems of a formal system called Metamath,
which is known to have the same consistency strength as ZFC.

We hope that future work will manage to tighten the upper bound still further.
\section{A Turing Machine that Cannot Be Shown to Run Forever Using ZFC}

We present a \statenumstate Turing machine whose behavior is \emph{independent of ZFC}; it is not possible to prove that this machine halts or doesn't halt using the axioms of ZFC, assuming that a stronger set theory is consistent. \ It's therefore impossible to prove the value of \bbstatenum to be any given value without assuming axioms more powerful than ZFC, assuming that ZFC is consistent.

For an explicit listing of this machine, see Appendix~\ref{sec:explicitz}.

We call this machine $Z$. \ One way to build this machine would be to start with the axioms of ZFC and apply the inference rules of first-order logic repeatedly in each possible way so as to enumerate every statement ZFC could prove, and to halt if ever a contradiction was found. \ While this method is conceptually simple, to actually construct such a machine would lead to a huge number of states, because it would require writing a program to manipulate the axioms of ZFC and the inference rules of first-order logic, and then compiling that program all the way down to Turing machine states.

\subsection{Friedman's Mathematical Statement} \label{sec:friedmanstate}

Thankfully, a simpler method exists for creating $Z$. \ Friedman~\cite{friedman}
was able to derive a graph theoretic statement whose truth implies the consistency of ZFC, and which is false if ZFC is inconsistent. Moreover, like most
such conditional statements about the consistency of formal systems,
Friedman's theorem could itself be formalized and proved in a fragment
of Peano arithmetic, so we can talk about it in the same
theory-independent terms with which we talk about (say) the Prime
Number Theorem, or any other result in elementary number theory. \footnotemark
\footnotetext{In fact, Friedman's statement is equivalent to the consistency of SRP (``stationary Ramsey property''), which is a system of axioms more powerful than ZFC. \ Because SRP is strictly more powerful than ZFC (it in fact consists of ZFC plus some additional axioms), the consistency of SRP implies the consistency of ZFC, and the inconsistency of ZFC implies the inconsistency of SRP.} \
Here is Friedman's statement (the notation will be explained in the rest of this section):

\begin{statement} \label{eq:friedman}
For all $k, n, r > 0$, every order invariant graph on $[\mathbb{Q}]^{\le k}$ has a free $\{x_1,\dots,x_r, \\
\textrm{ush}(x_1),...,\textrm{ush}(x_r)\}$ of complexity $\le (8knr)!$, each $\{x_1, \dots, x_{(8kni)!}\}$, for $i > 0$ and $(8kni!) \le r$, reducing $[x_1 \cup \dots \cup x_i \cup \{0,\dots,n\}]^{\le k}$. \cite{friedman}
\end{statement}

If $s$ is a set, the operation $(.)^{\le k}$ refers to the set of all subsets of $s$ with size at most $k$.

A graph on $[\mathbb{Q}]^{\le k}$ is an irreflexive symmetric relation on $[\mathbb{Q}]^{\le k}$. In other words, it can be thought of as a graph whose vertices are elements of $[\mathbb{Q}]^{\le k}$, and whose edges are undirected, connect pairs of vertices, and never connect vertices to themselves.

A \emph{free} set is a set such that no pair of elements in that set are connected by an edge.

A number of \emph{complexity} at most $c$ refers to a number that can be written as a fraction $a/b$, where $a$ and $b$ are both integers with absolute value less than or equal to $c$. \ A set has complexity at most $c$ if all the numbers it contains have complexity at most $c$.

An \emph{order invariant graph} is a graph containing a countably infinite number of nodes. \ In particular, it has one node for each finite set of rational numbers. \ The only numbers relevant to the statement are numbers of complexity $(8knr)!$ or smaller. \ In every description of nodes that follows, the term \emph{node} refers both to the object in the order invariant graph and to the set of numbers that it represents.

In an order invariant graph, two nodes $(a,b)$ have an edge between them if and only if each other pair of nodes $(c,d)$ that is \emph{order equivalent} with $(a,b)$ has an edge between them. \ Two pairs of nodes $(a, b)$ and $(c, d)$ are \emph{order equivalent} if $a$ and $c$ are the same size and $b$ and $d$ are the same size and if for all $1 \le i \le |a|$ and $1 \le j \le |b|$, the $i$-th element of $a$ is less than the $j$-th element of $b$ if and only if the $i$-th element of $c$ is less than the $j$-th element of $d$.

To give some trivial examples of order invariant graphs: the graph with no edges is order invariant, as is the complete graph. \ A less trivial example is a graph on $[\mathbb{Q}]^{\le 2}$, in which each node corresponds to a set of two rational numbers of a given complexity, and there is an edge between two nodes if and only if their corresponding sets $a$ and $b$ satisfy $|a| = |b| = 2$ and $a_1 < b_1 < a_2 < b_2$. \ (Because edges are undirected in order invariant graphs, such an edge will exist if \emph{either} assignment of the vertices to $a$ and $b$ satisfies the inequality above.)

The \emph{ush()} function takes as input a set and returns a copy of that set with all non-negative numbers in that set incremented by $1$.

For vertices $x$ and $y$, $x \le_{rlex} y$ if and only if $x = y$ or $x_{|x|-i} < y_{|y|-i}$ where $i$ is the least integer such that $x_{|x|-i} \not= y_{|y|-i}$.\footnote{Friedman recommended in private communication that we use the $\le_{rlex}$ comparator to compare vertices, instead of comparing their maximum elements as described in his manuscript.} \ (The $\le_{rlex}$ operation creates a lexicographic ordering over the vertices, weighting the last and largest elements of those vertices most heavily. Like with lexicographic orderings, if the two vertices are identical but one is longer, the shorter one comes first.)

Finally, a set of vertices $X$ \emph{reduces} a set of vertices $Y$ if and only if for all $y \in Y$, there exists $x \in X$ such that
either $x = y$ or $x \le_{rlex} y$ and an edge exists between $x$ and $y$.

\subsection{Implementation Methods}

To create $Z$, we needed to design a Turing machine that halts if Statement~\ref{eq:friedman} is false, and loops if Statement~\ref{eq:friedman} is true. \ Such a Turing Machine's behavior is necessarily independent of ZFC, because the truth or falsehood of Statement~\ref{eq:friedman} is independent of ZFC, assuming the consistency of SRP.~\cite{friedman} SRP is an extension of ZFC by certain relatively mild large cardinal hypotheses, and is widely regarded by set theorists as consistent. For more information about SRP, see~\cite{srp}.

To design such a Turing machine, we wrote a Laconic program which encodes Friedman's statement, then compiled the program down to a description of a single-tape, $2$-symbol Turing machine. \ What follows is an extremely brief description of the design of the Laconic program; for the documented Laconic code itself, along with a detailed explanation of the full compilation process, see~\cite{github}.

Our Laconic program begins by looping over all non-negative values for $k$, $n$, and $r$. \ For each trio $(k, n, r)$, our program generates a list $N$ of all numbers of complexity at most $(8knr)!$. \ These numbers represent the vertices in our putative order invariant graph. \ Because Laconic does not support floating-point numbers, the list is entirely composed of integers; it is a list of all numbers that can be written in the form $(((8knr)!)!)\frac{i}{j}$, where $i$ and $j$ are integers satisfying $-(8knr)! \le i \le (8knr)!$ and $1 \le j \le (8knr)!$. \ (Note that any number that can be expressed in this form is necessarily an integer, because of the large scaling factor in front.)

After we generate $N$, we generate the nodes in a potential order invariant graph by adding to $N$ all possible lists of $k$ or fewer numbers from $N$. \ We call this list of lists $V$.

We iterate over all binary lists of length $|V|^2$. \ Any such list $E$ represents a possible set of edges in the graph. \ To be more precise, we say that an edge exists between node $i$ and node $j$ (represented by $V_i$ and $V_j$ respectively) if and only if $E_{i|V| + j}$ is $1$.

For any graph $(V, E)$, we say that it is ``valid'' if the following three conditions hold:

\begin{enumerate}

\item No node has an edge to itself.
\item If an edge exists between node $i$ and node $j$, an edge also exists between node $j$ and node $i$.
\item The graph has a free $\{x_1,\dots,x_r, \textrm{ush}(x_1),...,\textrm{ush}(x_r)\}$, each  $\{x_1, \dots, x_{(8kni)!}\}$ reducing $[x_1 \cup \dots \cup x_i \cup \{0,\dots,n\}]^{\le k}$.

\end{enumerate}

For each list of nodes $V$, we loop over every possible binary list $E$, and if no pair $(V, E)$ yields a valid graph, we halt.

When verifying the validity of a graph, checking the first two conditions is trivial, but the third merits further explanation. \ In order to verify that a given graph $(V, E)$ has a free \\ $\{x_1,\dots,x_r, ush(x_1),...,ush(x_r)\}$, each  $\{x_1, \dots, x_{(8kni)!}\}$ reducing $[x_1 \cup \dots \cup x_i \cup \{0,\dots,n\}]^{\le k}$, we look at every possible subset of the nodes in $V$. \ For each subset, we verify that it has length $r$, that $\textrm{ush}(x_1),...,\textrm{ush}(x_r)$ all exist in $V$, and for each $i$ such that $(8kni)! \le r$, that $\{x_1, \dots, x_{(8kni)!}\}$ reduces $[x_1 \cup \dots \cup x_i \cup \{0,\dots,n\}]^{\le k}$. \ Once we have found such a subset, we know that the third conditon is satisfied.

\section{A Turing Machine that Encodes Goldbach's Conjecture} \label{sec:g}

We present a \gbstatenumstate Turing machine that \emph{encodes Goldbach's Conjecture}; in other words, to know whether this machine halts is to know whether Goldbach's Conjecture is true. \ It's therefore impossible to prove the value of \bbgbstatenum without simultaneously proving or disproving Goldbach's Conjecture.\footnote{Note that our tools were primarily meant to encode complex statements into Turing machines, such as Statement~\ref{eq:friedman}. \ Because Goldbach's Conjecture is so simple, it's feasible in that case to make dramatically smaller Turing machines through a more direct approach.  Indeed, after a preprint of this paper was circulated online, ``Jared S'' and ``code golf addict'' created Turing machines for Goldbach's Conjecture with $47$ and $31$ states respectively.~\cite{comments}}

Recall that Goldbach's Conjecture is as follows:

\begin{statement}
\emph{Every even integer greater than 2 can be expressed as the sum of two primes.}
\label{goldbachstatement}
\end{statement}

Because Goldbach's Conjecture is so simple to state, the Laconic program encoding the statement is also quite simple. \ It can be found in Appendix~\ref{sec:applac}. \ A detailed explanation of the compilation process, documentation for the Laconic language, and an explicit description of this Turing machine are available at~\cite{github}.

\section{A Turing Machine that Encodes the Riemann Hypothesis}

We present a \rmstatenumstate Turing machine that \emph{encodes the Riemann Hypothesis}; in other words, to know whether this machine halts is to know whether the Riemann Hypothesis is true. \ An explicit description of this machine can be found at~\cite{github}.

The Riemann Hypothesis is traditionally stated as follows:

\begin{statement}
\emph{The Riemann zeta function has its zeros only at the negative even integers and the complex numbers with real part 1/2.}
\label{goldbachstatement}
\end{statement}

\subsection{Equivalent Statement}

Instead of encoding the Riemann zeta function into a Laconic program, it is simpler to use the following statement, which was shown by Davis, Matijasevic, aand Robinson~\cite{riemann} to be equivalent to the Riemann Hypothesis:

\begin{statement} \label{eq:riemann}
For all integers $n \ge 1$,
$$\left(\left(\sum_{k \le \delta(n)} \frac{1}{k}\right) - \frac{n^2}{2}\right)^2 < 36n^3$$
\end{statement}

The function $\delta(n)$ used in Statement~\ref{eq:riemann} is defined as follows: \\

\begin{nscenter}
$\eta(j) = p$ if $j = p^k$, $p$ is prime, $k$ is a positive integer \\
$\eta(j) = 1$ otherwise
\end{nscenter}
$$\delta(x) = \prod_{n<x}\prod_{j \le n} \eta(j)$$

\subsection{Implementation Methods}

Statement \ref{eq:riemann} is equivalent to the following statement, which involves only positive integers\footnotemark:
\footnotetext{Although it is not immediately obvious, $\frac{\delta(n)!}{k}$ is necessarily an integer for all $k \le \delta(n)$, and $\frac{\delta(n)!}{2}$ is an integer for all $n > 1$.}

$$l(n) < r(n)$$ for all positive integers $n$, where

$$l(n) = a(n)^2 + b(n)^2$$
$$r(n) = 36n^3(\delta(n)!)^2 + 2a(n)b(n)$$.
$$a(n) = \sum_{k \le \delta(n)} \frac{\delta(n)!}{k}$$
$$b(n) = \frac{n^2 \delta(n)!}{2}$$

To check the Riemann Hypothesis, our program computes $a(n)$, $b(n)$, $l(n)$, and $r(n)$, in that order, for each possible value of $n$. \ If $l(n) \ge r(n)$, our program halts.

\section{Laconic}

Laconic is a programming language designed to be both user-friendly and easy to compile down to parsimonious Turing machine descriptions.

Laconic is a strongly-typed language that supports recursive functions. Laconic compiles to an intermediate language called TMD. \ TMD programs are spread across multiple files and grouped into directories. \ TMD directories are meant to represent sequences of commands that could be given to a multi-tape, $3$-symbol Turing machine, using the Turing machine abstraction that allows the machine to read and write from one head at a time.

For an example of a Laconic program, see Appendix~\ref{sec:applac}. \ For an illustration of the compilation process, see Figure~\ref{fig:compilation}.

\section{TMD}

TMD is a programming language designed to help the user describe the behavior of a multi-tape, $3$-symbol Turing machine with a function stack. Each tape is infinite in one direction and supports three symbols: \texttt{\_}, \texttt{1}, and \texttt{E}. \ The blank symbol is \texttt{\_}: that is, \texttt{\_} is the only symbol that can appear on the tape an infinite number of times. \ The tape must always have the form $\texttt{\_}?(1|E)^+\texttt{\_}^{\infty}$; in other words, each tape must always contain a string of \texttt{1}'s and \texttt{E}'s of size at least 1, possibly preceded by a \texttt{\_} symbol, and necessarily followed by an infinite number of copies of the \texttt{\_} symbol.

What is the purpose of having a language like TMD as an intermediary between Laconic and a description of a single-tape machine? \ The concept of tapes in a multi-tape Turing machine and the concept of variables in standard imperative programming languages map to one another very nicely. \ The idea of the Laconic-to-TMD compiler is to encode the value of each variable on one tape. \ Then, each Laconic command that manipulates the value of one or more variables compiles down to a TMD function call that manipulates the tapes that correspond to those variables appropriately.

As an example, consider the following Laconic command: \\ \\
\texttt{a=b*c;} \\

This Laconic command assigns the value of \texttt{b*c} to the variable \texttt{a}. \ It compiles down to the following TMD function call: \\ \\
\texttt{function BUILTIN\_multiply a b c} \\

This function call will result in \texttt{BUILTIN\_multiply} being run on the three tapes \texttt{a}, \texttt{b}, and \texttt{c}. \ This will cause the symbols on tape \texttt{a} to take on a representation of an integer whose value is equal to $bc$.

In turn, the TMD code compiles directly to a string of bits that are written onto the tape at the start of the Turing machine's execution.

A TMD directory consists of three types of files:

\begin{enumerate}
\item The \texttt{functions} file. \ This file contains a list of the names of all the functions used by the TMD program. \ The top function in the file is pushed onto the stack at initialization. \ When this top function returns, the Turing machine halts.
\item The \texttt{initvar} file. \ This file contains the non-blank symbols that start in each register (or tape) at initialization.
\item Any files used to describe TMD functions. \ These files all end in a \texttt{.tfn} extension and only have any relevance to the compiled program if they show up in the functions file.
\end{enumerate}

\section{Compilation and Processing}
\label{sec:compandproc}

There are two ways to think about the layout of the tape symbols: with a $4$-symbol alphabet ($\{\texttt{\_}, \texttt{1}, \texttt{H}, \texttt{E}\}$, blank symbol \texttt{\_}), and with a $2$-symbol alphabet ($\{\texttt{a}, \texttt{b}\}$, blank symbol \texttt{a}). \ The $2$-symbol alphabet version is the one that's ultimately used for the results in this paper, since we advertised a Turing machine that used only two symbols. \ However, in nearly all parts of the Turing machine, the $2$-symbol version of the machine is a direct translation of the $4$-symbol version, according to the following mapping: \\ \\
$\texttt{\_} \leftrightarrow \texttt{aa}$ \\
$\texttt{1} \leftrightarrow \texttt{ab}$ \\
$\texttt{H} \leftrightarrow \texttt{ba}$ \\
$\texttt{E} \leftrightarrow \texttt{bb}$ \\

The sections that follow sometimes refer to the \texttt{ERROR} state. \ Transitions to the \texttt{ERROR} state should never be taken under any circumstances, and are useful for debugging purposes.

\subsection{Concept} \label{sec:ontape}

A directory of TMD functions is converted at compilation time to a string of bits to be written onto the tape, along with other states designed to interpret these bits. \ The resulting Turing machine has three main components, or \emph{submachines}:

\begin{enumerate}
\item The \emph{initializer} sets up the basic structure of the variable registers and the function stack.
\item The \emph{printer} writes down the binary string that corresponds to the compiled TMD code.
\item The \emph{processor} interprets the compiled binary, modifying the variable registers and the function stack as necessary.
\end{enumerate}

The Turing machine's control flow proceeds from the initializer to the the printer to the interpreter. \ In other words, initializer states point only to initializer states or to printer states, printer states point only to printer states or to interpreter states, and interpreter states point only to interpreter states or the \texttt{HALT} state.

This division of labor, while seemingly straightforward, actually constitutes an important idea. \ The problem of the compiler is to convert a higher-level representation---a machine with many tapes, a larger alphabet, and a function stack---to the lower-level representation of a machine with a single tape, a $2$-symbol alphabet and no function stack. \ The immediately obvious solution, and the one taught in every computability theory class as a proof of the equivalence of different kinds of Turing machines, is to have every ``state'' in the higher-level machine compile down to many states in the lower-level machine. %See Figure~\ref{fig:mttost} for a visual representation of what such a conversion might look like.

While simple, this approach is suboptimal in terms of the number of states. \ As is nearly always true when designing systems to be parsimonious, the clue that improvement is possible lies in the presence of repetition. \ Each state transition in the higher-level machine is converted to a group of lower-level states with the same basic structure. \ Why not instead explain how to perform this conversion exactly once, and then apply the conversion many times?

This idea is at the core of the division of labor described previously. \ We begin by writing a description of the higher-level machine onto the tape, and then ``run'' the higher-level machine by reading what is on the tape with a set of states that understands how to interpret the encoded higher-level machine. \ We refer to this idea as \emph{on-tape processing}.

In this paper, we use TMD as the representation of the higher-level machine.\footnotemark
\footnotetext{Note that instead of TMD, the on-tape processing scheme could be used for any language, assuming the designer provides both a processor and an encoding for that language. \ We chose TMD because it made the interpreter easy to write, but other minimalist languages, like Unlambda~\cite{unlambda}, Brainf*ck~\cite{brainfuck}, or Iota and Jot~\cite{iota}, might be good candidates for parsimonious designs, with the additional advantage of being already known to some programmers! \ Thanks to Luke Schaeffer for this point.}
The printer writes the TMD program onto the tape, and the processor executes it. As a result of using this scheme, we incur a constant \emph{additive} overhead---we have to include the processor in our final Turing machine---but we avoid the constant \emph{multiplicative} overhead required for the na\"ive scheme.

Is this additive overhead small enough to be worth it? \ We found that it is. \ Our implementation of the processor requires 3,860 states. \ (See Section~\ref{sec:cost} for a detailed breakdown of the state cost by submachine.) \ In contrast to this additive overhead of 3,860, the na\"ive approach incurs a large multiplicative overhead that depends in part on how many states must be used to represent each higher-level state transition, and in part on how efficient an encoding scheme can be devised for the on-tape approach. \ The following table compares the performance of on-tape processing to the performance of an implementation that used the na\"ive approach. \ The comparison is shown for three kinds of machines: a machine that halts if and only if Goldbach's Conjecture is false, a machine that halts if and only if the Riemann Hypothesis is false, and a machine whose behavior is independent of ZFC.

\begin{center}
    \begin{tabular}{||c c c||}
    \hline
    Program & States (Na\"ive) & States (On-Tape Processing) \\ [0.5ex]
    \hline
    Goldbach & 7,902 & \gbstatenum\\
    \hline
    Riemann & 36,146 & \rmstatenum\\
    \hline
    ZFC & 340,943 & \statenum\\
    \hline
    \end{tabular}
\end{center}

As can be seen from this table, on-tape interpretation results in huge gains, particularly in large and complex programs.

The subsections that follow describe each of the three submachines---the initializer, the printer, and the processor---in greater detail.

\subsection{The Initializer}

The initializer starts by writing a counter onto the tape which encodes how many registers there will be in the program. \ Using the value in that counter, it creates each register, with demarcation patterns between registers, and unique identifiers for each register. \ Each register's value begins with the pattern of non-blank symbols laid out in the \texttt{initvar} file. \ The initializer also creates the program counter, which starts at 0, and the function stack, which starts out with only a single function call to the top function in the \texttt{functions} file.

Figure~\ref{fig:postinit} is a detailed diagram describing the tape's state when the initializer passes control to the printer.

\begin{figure}
\begin{center}
\includegraphics[scale=0.42]{figs/postinit.png}
\caption{The state of the Turing machine tape after the initializer completes. \ The TMD program being expressed in Turing machine form is described in full in Appendix~\ref{sec:apptmd}. \ The top bar is a high-level description of what each part of the Turing machine tape represents. \ The middle bar is an encoding of the tape in the standard $4$-symbol alphabet; the bottom bar is simply the translation of that tape into the $2$-symbol alphabet. \ For a more detailed explanation of how to interpret the tape patterns, see~\cite{github}. \label{fig:postinit}}
\end{center}
\end{figure}

\subsection{The Printer} \label{sec:introspect}

\subsubsection{Specification}

The printer writes down a long binary string which encodes the entirety of the TMD program onto the tape.

Figure~\ref{fig:postprog} shows the tape's state when the printer passes control to the processor.

\begin{figure}
\begin{center}
\includegraphics[scale=0.42]{figs/postprog.png}
\caption{The state of the Turing machine tape after the printer completes. \ The TMD program being expressed in Turing machine form is described in full in Appendix~\ref{sec:apptmd}. \ The top bar is a high-level description of the entire tape; unfortunately, at this point there are so many symbols on the tape that it is impossible to see everything at once. \ For a detailed view of the first two-thirds of the tape (registers, program counter, and stack), see Figure~\ref{fig:postinit}. \ The bottom three bars show a zoomed-in view of the program binary. \ From the top, the second bar gives a high-level description of what each part of the program binary means; the third bar gives the direct correspondence between $4$-symbol alphabet symbols on the tape and their meaning in TMD; the fourth and final bar gives the translation of the third bar into the $2$-symbol alphabet. \ For a more detailed explanation of the encoding of TMD into tape symbols, see~\cite{github}. \label{fig:postprog}}
\end{center}
\end{figure}

\subsubsection{Introspection}

Writing down a long binary string onto a Turing machine tape in a parsimonious fashion is not as straightforward as it might initially appear. \ The first idea that comes to mind is simply to use one state per symbol, with each state pointing to the next, as shown in Figure~\ref{fig:naiveprog}.

\begin{figure}
\begin{center}
\includegraphics[scale=0.28]{figs/naiveprog.png}
\caption{A na\"ive implementation of the printer. \ In this example, the hypothetical program is ten bits long, and the printer uses ten states, one for each bit. \ In the diagram, the blue symbol is the symbol that is read on a transition, the red letter indicates the direction the head moves, and the green symbol indicates the symbol that it written. \ Note the lack of transitions on reading a \texttt{b}; this is because in this implementation, the printer will only ever read the blank symbol, which is \texttt{a}, since the head is always proceeding to untouched parts of the tape. \ It therefore makes no difference what behavior the Turing machine adopts upon reading a \texttt{b} in states 1-10 (and therefore \texttt{b} transitions are presumed to lead to the \texttt{ERROR} state) \label{fig:naiveprog}}
\includegraphics[scale=0.28]{figs/introspectprog.png}
\caption{An introspective implementation of the printer. \ In this example, the hypothetical program is $k=10$ bits long, and so the word size must be 2 (since $w=2$ is the largest $w$ such that $w2^w \le 10$). \ There are therefore $n_w = \left \lceil{\frac{k}{w}}\right \rceil = 5$ data states, each encoding two bits. \ The \texttt{b} transitions carry the information about the encoding; note that each one only points to one of the last four data states. \ The last four data states have in parentheses what word we mean to encode if we point to them. \label{fig:introspectprog}}
\end{center}
\end{figure}

On closer examination, however, this approach is quite wasteful for all but the smallest binary files. \ Every \texttt{a} transition points to the next state in the sequence, and none of the \texttt{b} transitions are used at all! \ Indeed, the only information-bearing part of the state is the single bit contained in the choice of which symbol to write. \ But in theory, far more information than that could be encoded in each state. \ In a machine with $n$ states, each state could contain $2(\log_2(n) + 1)$ bits of information, because each of its two transitions could point to any of the $n$ states, and write either an \texttt{a} or a \texttt{b} onto the tape. \ Of course, this is only in theory; in practice, to extract the information contained in therefore Turing machine's states and translate it into bits on the tape is nontrivial.

We will use a scheme originally conceived by Ben-Amram and Petersen~\cite{benamram} and refined further and suggested to us by Luke Schaeffer. \ It does not achieve the optimal theoretical encoding described above, but is relatively simple to implement and understand, and is within a factor of $2$ of optimal for large binary strings. \ Schaeffer named Turing machines that use this idea \emph{introspective}.

Introspection works as follows. \ If the binary string contains $k$ bits, then let $w$ be the \emph{word size}. The word size $w$ takes the largest value it can such that $w2^w \le k$. \ We can split the binary string into $n_w = \left \lceil{\frac{k}{w}}\right \rceil$ \emph{words} of $w$ bits each (we can pad the last word with the blank symbol). \ In our scheme, each word in the bit-string is represented by a \emph{data state}. \ Each data state points to the state representing the next word in the sequence for its \texttt{a} transition, but which state the \texttt{b} transition points to encodes the next word. \ Every \texttt{b} transition points to one of the last $2^w$ data states, thereby encoding $w$ bits of information.

Of course, the encoding is useless until we specify how to extract the encoded bit-string from the data states. \ The extraction scheme works as follows. \ To query the $i^\textrm{th}$ data state for the bits it encodes, we run the data states on the string $\texttt{a}^{i-1}\texttt{b}\texttt{a}^{\infty}$ (a string of $i-1$ \texttt{a}'s followed by a \texttt{b} in the $i^\textrm{th}$ position). \ After running the data states on that string, what remains on the tape is the string $\texttt{b}^{i-1}\texttt{a}\texttt{b}^r\texttt{a}^{\infty}$, assuming that the $i^\textrm{th}$ data state pointed to the $r^\textrm{th}$-to-last data state. \ Thus, what we're left with is essentially a unary encoding of the ``value'' of the word in binary. \ Thus, the job of the extractor is to set up a binary counter which removes one \texttt{b} at a time and increments the counter appropriately. \ Then, afterward, the extractor reverts the tape back to the form $\texttt{a}^i\texttt{b}\texttt{a}^{\infty}$, shifts all symbols on the tape over by $w$ bits, and repeats the process. \ Finally, when the state beyond the last data state sees a \texttt{b} on the tape, we know that the process has completed, and we can pass control to the processor. \ Figure~\ref{fig:introspectprog} shows the whole procedure.

How much have we gained by using introspection for encoding the program binary, instead of the na\"ive approach? \ It depends on how large the program binary is. \ Using introspection incurs an $O(\log k)$ \emph{additive} overhead, because we have to include the extractor in our machine. \ (Our implementation of the extractor takes $10w + 17$ states. It's possible to build a constant-size extractor, but it's not worth it for our value of $w$) \ In return, we save a \emph{multiplicative} factor of $w$ (which scales with $\log k$) on the number of data states needed.

This is plainly not worth it for the $10$-bit example binary shown in Figs.~\ref{fig:naiveprog} and~\ref{fig:introspectprog}. \ For that binary, we require $69$ additional states for the extractor in order to save $5$ data states. \ For real programs, however, it is worth it, as can be seen from the following table.

\begin{center}
    \begin{tabular}{||c c c c c c c||}
    \hline
    Program & Binary Size & $w$ & $n_w$ & Extractor Size & States (Na\"ive) & States (Introspective) \\ [0.5ex]
    \hline\hline
    Example TMD & 116 & 4 & 29 & 57 & 116 & 86 \\
    \hline
    Goldbach & 4,964 & 9 & 552 & 107 & 4,964 & 659 \\
    \hline
    Riemann & 9,532 & 10 & 1,024 & 117 & 9,532 & 1,141 \\
    \hline
    ZFC & 38,864 & 11 & 3,534 & 127 & 38,864 & 3,661 \\
    \hline
    \end{tabular}
\end{center}

One minor detail concerns the numbers presented for the Riemann program. \ Ordinarily, with a binary of size 9,532, we would opt to split the program into 1,060 words of 9 bits each plus a 107-state extractor, since 9 is the greatest $w$ such that $w2^w <$ 9,532. \ But because 9,532 is so close to the ``magic number'' 10,240, it's actually more parsimonious to pad the program with copies of the blank symbol until it's 10,240 bits long, and split it into 1,024 words of $10$ bits each plus a $117$-state extractor.


\subsection{The Processor}

The processor's job is to interpret the code written onto the tape and modify the variable registers and function stack accordingly. \ The processor does this by the following sequence of steps:  \\ \\
START:
\begin{enumerate}
\item Find the function call at the top of the stack. Mark the function $f$ in the code whose ID matches that of the top function call.
\item Read the current program counter. Mark the line of code $l$ in $f$ whose line number matches the program counter.
\item Read $l$. Depending on what type of command $l$ is, carry out one of the following three lists of tasks.
\end{enumerate}

\noindent IF $l$ IS AN EXPLICIT TAPE COMMAND:
\begin{enumerate}
\item Read the variable name off $l$. Index the variable name into the list of variables in the top function on the stack. This list of variables corresponds to the mapping between the function's local variables and the register names.
\item Match the indexed variable to its corresponding register $r$. Mark $r$. Read the symbol $s_r$ to the right of the head marker in that register.
\item Travel back to $l$, remembering the value of $s_r$ using states. Find and mark the reaction $x$ corresponding to the symbol. See what symbol $s_w$ should be written in response to reading $s_r$.
\item Travel back to $r$, remembering the value of $s_w$ using states. Replace $s_r$ with $s_w$.
\item Travel back to $x$. See which direction $d$ the head should move in response to reading $s_r$.
\item Travel back to $r$, remembering the value of $d$ using states. Move the head marker accordingly.
\item Travel back to $x$. See if a jump is specified. If a jump is specified, copy the jump address onto the program counter. Otherwise, increment the program counter by 1.
\item Go back to START.
\end{enumerate}

\noindent IF $l$ IS A FUNCTION CALL:
\begin{enumerate}
\item Write the function's name to the top of the stack.
\item For each variable in the function call, index the variable name into the list of variables in the top function on the stack. This list of variables corresponds to the mapping between the function's local variables and the register names. Push the corresponding register names in the order that they correspond to the variables in the function call.
\item Copy the current program counter to the return address of the newborn function call at the top of the stack.
\item Replace the current program counter with 0 (meaning ``read the first line of code'').
\item Go back to START.
\end{enumerate}

\noindent IF $l$ IS A RETURN STATEMENT:
\begin{enumerate}
\item Replace the current program counter with $f$'s return address.
\item Increment the program counter by 1.
\item Erase the call to $f$ from the top of the stack.
\item Check if the stack is now empty. If so, halt.
\item Go back to START.
\end{enumerate}

\subsection{Cost Analysis} \label{sec:cost}

It's worthwhile to analyze the relative contributions of the initializer, the printer, and the processor to the machine's final state count. \ The following table lists the number of states in each submachine for each of the four different TMD programs under discussion.

\begin{center}
    \begin{tabular}{||c c c c c||}
    \hline
    Program & Initializer & Printer & Processor & Total \\ [0.5ex]
    \hline\hline
    Example TMD & 349 & 86 & 3,860 & 4,295 \\
    \hline
    Goldbach & 369 & 659 & 3,860 & \gbstatenum \\
    \hline
    Riemann & 371 & 1,141 & 3,860 & \rmstatenum \\
    \hline
    ZFC & 389 & 3,661 & 3,860 & \statenum \\
    \hline
    \end{tabular}
\end{center}

As can be seen from this table, the processor makes the largest contribution to all four programs. \ Improving the processor, therefore, is probably the best approach for improving upon the bounds we present. \ Equally clear, however, is that for programs more complicated than the ones presented here, the cost of the printer will grow almost linearly but the cost of the processor will stay the same. \ The cost of the initializer grows very slightly with the complexity of programs because of the need to initialize additional registers.

Improving the printer, and with it the TMD and Laconic languages, is probably the best approach for reducing state count for very large and complex programs.

\section{Future Work}

This paper still leaves a three orders-of-magnitude gap between the smallest $n$, namely \statenumcomma for which $BB(n)$ is known to be independent of ZF set theory, and the largest $n$, namely $4$, for which $BB(n)$ is known to be determinable. \ We regard it as a fascinating problem to pin down the truth here: for example, is it conceivable that $BB(10)$ or even $BB(6)$ might be independent of ZF? \ If so, that would arguably force a qualitative change in our understanding of the G\"{o}del incompleteness phenomenon---showing that incompleteness from strong set theories rears its head for much simpler arithmetical questions than had previously been known.

A more immediate question is how much further $Z$'s state count can be reduced. \ We are optimistic about the possibility of further reductions. \ For example, one could adapt the processor-printer model to use a better language than TMD. \ Ideally, one wants a language whose processor contains fewer states than TMD's, and whose typical programs are \emph{also} shorter than TMD programs. \ A few ideas have been proposed for this~\cite{comments}, many of them related in some way to lambda calculus.

Other future work might involve further use of our Laconic language to upper-bound the `complexities' of mathematical statements and algorithms, in as standardized and model-independent a way as possible. \ Perhaps Laconic could be used to measure the complexity of other well-known conjectures, or even to compare different algorithms for solving the same problem to each other (e.g., to try to quantify the notion that an insertion sort is simpler than a merge sort)!

\section{Acknowledgements}

We thank Prof.\ Harvey Friedman for having done the crucial theoretical work that made this project feasible. \ Prof.\ Friedman was endlessly available over email, and provided us with detailed clarifications when we needed them.

We thank Luke Schaeffer for his early help, as well as his help designing introspective Turing machines.

We thank Alex Arkhipov for introducing us to the term ``code golfing.''

We thank the commenters on Scott Aaronson's blog~\cite{comments} for their ideas and suggestions.

Supported by an Alan T.\ Waterman Award from the National Science Foundation, under grant no.\ 1249349.

\begin{thebibliography}{100}
\bibitem{comments} Aaronson, S. ``The 8000th Busy Beaver number eludes ZF set theory: new paper by Adam Yedidia and me.'' May 3, 2016. \url{http://www.scottaaronson.com/blog/?p=2725#comments} [Scott Aaronson publicized a preprint of our results on his blog, and many of his readers offered helpful comments and suggestions for future improvements.]
\bibitem{iota} Barker, C. ``Iota and Jot: the Simplest Languages?''
http://semarch.linguistics.fas.nyu.edu/barler/Iota/
[A website describing the Iota and Jot programming languages]
\bibitem{benamram} Ben-Amram, A., Petersen, H. ``Improved Bounds for Functions Related to Busy Beavers'' Theory of Computing Systems 35, 1-11 (2002)
\bibitem{bbfour} Brady, A.H. ``Solution of the Non-computable `Busy Beaver' game for $k=4$.'' Abstracts for: ACM Computer Science Conference (Washington, DC, February 18-20, 1975), p. 27, ACM, 1975.
%\bibitem{riemann} Browder, F. ``Mathematical Developments Arising from Hilbert Problems.'' American Mathematical Society. Volume 28, Part 1.
\bibitem{calude} Calude, C., Calude, E. ``Evaluating the Complexity of Mathematical Problems: Part 1,'' ``Evaluating the Complexity of Mathematical Problems: Part 2.'' Complex Systems 18, pp. 387-401. 2010.
\bibitem{chaitin} Chaitin, G. ``The Limits of Mathematics.'' pp. 79. 1994.
\bibitem{bigbbvalues} Cloudy176, Wythagoras. ``A good bound for S(7)?'' 2014. \url{http://googology.wikia.com/wiki/User_blog:Wythagoras/A_good_bound_for_S%287%29%3F}
\bibitem{riemann} Davis, M., Matijasevic, Y., Robinson, J. ``Hilbert's Tenth Problem. Diophantine Equations: Positive Aspects of a Negative Solution'', 1974. Published in ``Mathematical developments arising from Hilbert problems'', Proceedings of Symposium of Pure Mathematics", XXVIII:323-378 AMS. Page 335.
\bibitem{grahamsnumber} Deedlit11, Wythagoras. ``Okay, more Turing machines.'' 2013.
\url{http://googology.wikia.com/wiki/User_blog:Deedlit11/Okay,_more_Turing_machines}
\bibitem{friedman} Friedman, H. ``Order Invariant Graphs and Finite Incompleteness.'' \url{https://u.osu.edu/friedman.8/files/2014/01/FIiniteSeqInc062214a-v9w7q4.pdf}
\bibitem{friedmancomm} Personal communications with H. Friedman.
\bibitem{friedmanlist} Friedman, H. ``Order Theoretic Equations, Maximality, and Incompleteness.'' June 7, 2014. \url{http://u.osu.edu/friedman.8/foundational-adventures/downloadable-manuscripts} \\
\#78.
\bibitem{srp} Friedman H. ``The Upper Shift Kernel Theorems.'' October 9, 2010. \url{https://u.osu.edu/friedman.8/files/2014/01/KernStruThm100910-1lu0b8v.pdf}
\bibitem{godelcohen} G\"odel, K. ``The Consistency of the Axiom of Choice and of the Generalized Continuum-Hypothesis with the Axioms of Set Theory.'' Published in 1940 by the Princeton University Press. Annals of Mathematics Studies.
\bibitem{koza} Koza, J. ``Spontaneous Emergence of Self-Replicating and Evolutionarily Self-Improving Computer Programs.'' in Artificial Life III (SFI Studies in the Sciences of Complexity, vol. XVII), C. G. Langton, Ed. Reading, MA: Addison-Wesley. pp. 225-262. 1994.
%\bibitem{riemann} Lagarias, J. ``An Elementary Problem Equivalent to the Riemann Hypothesis.'' The Amrican Mathematical Monthly, Vol. 109, No. 6, pp. 534-543 (2002) 
\bibitem{bbsmall} Lin, S., Rado, T. ``Computer Studies of Turing Machine Problems.'' Published in Journal of the ACM, Volume 12, Issue 2, April 1965. Pages 196-212.
\bibitem{unlambda} Madore, D. ``The Unlambda Programming Language.'' \url{http://www.madore.org/~david/programs/unlambda/} \\
{[A website describing the Unlambda programming language]}
\bibitem{bbimpossible} Marxen, H., Buntrock, J. ``Attacking the Busy Beaver 5.'' Bull EATCS, Vol. 40, pp. 247-251. 1990.
\bibitem{bbvalues} Marxen, H.
\url{http://www.drb.insel.de/~heiner/BB/} \\
{[A list of the known busy beaver values]}
\bibitem{brainfuck} M\"uller, U. ``Brainfuck.'' \url{http://www.muppetlabs.com/~breadbox/bf/} \\
{[A website describing the Brainf*ck programming language]}
\bibitem{stefan} O'Rear, S. \url{https://github.com/sorear/metamath-turing-machines} \\
{[A link to a GitHub repository containing Stefan O'Rear's 1919-state Turing machine and related software.]}
\bibitem{pargellis} Pargellis, A. ``The Spontaneous Generation of Digital {`Life.'}'' Physica D, 91, 86-96. 1996.
\bibitem{busybeaver} Rado, T. ``On Non-Computable Functions.'' Bell System Technical Journal, 41: 3. May 1962 pp 877-884.
\bibitem{schoenfield} Schoenfield, J. ``The Problem of Predicativity.'' Essays on the foundations of mathematics, Y. Bar-Hillel et al., eds., pp. 132-142. 1961.
\bibitem{universal} Smith, A. ``Universality of Wolfram's 2, 3 Turing Machine.'' Submitted for the Wolfram 2, 3 Turing Machine Research Prize. http://www.wolframscience.com/prizes/tm23/TM23Proof.pdf
\bibitem{newscience} Wolfram, S. ``A New Kind of Science.'' p. 709
\bibitem{universalsurvey} Woods, D. and Neary, T. ``The Complexity of Small Universal Turing Machines: a Survey.'' Theoretical Copmuter Science, 410(4), pp. 443-450. 2009.
\bibitem{github} Yedidia, A. \url{https://github.com/adamyedidia/parsimony} \\
{[A link to a GitHub repository containing all programs and Turing machines related to this paper, with accompanying documentation.]}
\bibitem{codegolf} \url{http://codegolf.stackexchange.com/} \\
{[A place where programmers go for recreational code golfing]}
\end{thebibliography}

\begin{appendices}

\section{Example Laconic Program: Goldbach's Conjecture} \label{sec:applac}

The following is an example Laconic program, which compiles down to the Turing machine $G$ mentioned in Section~\ref{sec:g} (which halts if and only Goldbach's Conjecture is false).

\input{goldbachlac}

For detailed documentation of the Laconic programming language, see~\cite{github}. \ To find this file specifically, navigate to \texttt{parsimony/src/laconic/laconic\_files/goldbach.lac} at~\cite{github}.

\section{Example TMD Program} \label{sec:apptmd}

The following is an example TMD directory, which compiles down to a binary string to be written on a Turing machine tape. \ It's the example used in illustrations throughout this paper, most notably in the example compilation shown in Figs.~\ref{fig:postinit} and~\ref{fig:postprog}. \ The program calls itself recursively three times until the starting symbol on each tape, \texttt{E}, is replaced with a \texttt{1}, at which point the program halts.

This TMD directory is called \texttt{example\_tmd\_dir}, and contains four files: \texttt{f.tmd}, \texttt{g.tmd}, \texttt{initvar}, and \texttt{functions}. \\ \\

\texttt{f.tmd}:
\input{ftmd}
\texttt{g.tmd}:
\input{gtmd}
\texttt{functions}:
\input{functions}
\texttt{initvar}:
\input{initvar}

For detailed documentation of the TMD programming language, see~\cite{github}. \ To find this directory specifically, navigate to \texttt{parsimony/src/tmd/tmd\_dirs/example\_tmd\_dir/} at~\cite{github}.

\section{Explicit Listing of $Z$} \label{sec:explicitz}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{figs/syntax.png}
\caption{This figure explains how to read a description of a single state. \ Note that ``\texttt{ERROR-}'' or ``\texttt{HALT--}'' denote transitions to the \texttt{ERROR} or \texttt{HALT} states, respectively (no further information is provided because what symbol is written and which direction the head moves are at that point irrelevant). \label{fig:syntax}}
\end{center}
\end{figure}

We present below an explicit listing of $Z$. \ For a more easily readable version of $Z$, complete with descriptive state names, see~\cite{github}.

We ran this Turing machine for 10,000,000,000 steps (more than half a day on our simulators) and within that time it did not halt. \ We note, however, that $Z$ was designed for parsimony rather than efficiency, and that this ``experiment'' is of little consequence! \ We similarly ran a Turing machine designed to test the conjecture that all perfect squares are less than $5$, and it ran for 2,895,083,899 steps (a couple hours on our simulator) before it found the counterexample $9$ and halted.

Figure~\ref{fig:syntax} explains how to interpret the description shown below. \ In addition, note the following:

\begin{enumerate}

\item The tape has a $2$-symbol alphabet, with tape symbols $\{\texttt{a}, \texttt{b}\}$ and blank symbol \texttt{a} (in other words, \texttt{a} is the only symbol that can appear an infinite times on the tape).
\item The start state of $Z$ is \texttt{0000}.
\item $Z$ will never transition to the \texttt{ERROR} state. \ Any transition to the \texttt{ERROR} state could be replaced by a transition to any other state (including \texttt{HALT}) and the Turing machine's behavior would remain identical.
\item $Z$ contains only one transition to the \texttt{HALT} state, out of state \zhaltstate.

\end{enumerate}

%\clearpage
\input{zfctm}

\end{appendices}

\end{document}

